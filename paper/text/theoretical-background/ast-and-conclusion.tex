\section{Abstract Syntax Tree}

The Abstract Syntax Tree (AST) is a tree-like data structure representing the essential syntactic structure of a program's source code. It is constructed by the syntax analysis phase of a compiler, immediately after lexical analysis. The AST serves as a crucial intermediate representation for subsequent compiler phases: semantic analysis, intermediate code generation, and code optimisation. It abstracts away inessential concrete syntax details (e.g.\ parentheses, semicolons) to focus on core syntactic and semantic information \cite{aho2007compilers}.

\begin{figure}[hb!]
    \centering
    \begin{tikzpicture}[level distance=1.5cm, sibling distance=4.5cm]
      \node {BinaryOperation: +}
        child { node {Literal: 2} }
        child { node {BinaryOperation: -}
          child { node {Variable: z} }
          child { node {Literal: 1} }
        };
    \end{tikzpicture}
    \caption{AST of the expression \texttt{2 + (z - 1)}}
    \label{fig:ast-example}
\end{figure}

In an AST, each node represents a construct occurring in the source code \cite{aho2007compilers}. These constructs can include operators (e.g.\ addition, subtraction), variables, control flow statements (e.g.\ if-then-else, loops), function calls, and literals. The children of a node represent its components or operands. For instance, in an AST for the expression \texttt{2 + (z - 1)}, as shown in Figure~\ref{fig:ast-example}, the root node represents a binary addition operation, with two children: one for the literal value \texttt{2}, and one for a binary subtraction operation, which in turn has children representing the variable \texttt{z} and the literal value \texttt{1}. Each node stores information about its construct type and related data (e.g.\ variable names, literal values), encoding hierarchical relationships and operator precedence \cite{aho2007compilers}.

\subsection{Abstraction from Concrete Syntax}

The AST abstracts away inessential concrete syntax details present in a parse tree \cite{aho2007compilers}. It omits grouping parentheses, statement-terminating semicolons, and parsing-only non-terminals, retaining only the constructs needed for semantic understanding. By eliminating syntactic sugar and focusing on semantic content, the AST provides a cleaner, more manageable structure for semantic analysis and code generation \cite{aho2007compilers}.

\subsection{Further Compiler Stages}

As an intermediate representation, the AST bridges initial code analysis and later compiler phases. It underpins semantic analysis—checking types, scopes, and other constraints—by providing a traversable structure. The AST also forms the basis for generating machine-independent intermediate code and enables code optimisation techniques through its well-defined hierarchy. A carefully designed AST thus directly impacts the efficiency and correctness of generated target code \cite{aho2007compilers}.

\section{Conclusion}

This chapter has explored the fundamental theoretical concepts that underpin the frontend of a compiler. We have examined the principles of formal languages, which provide the mathematical framework for defining the syntax of programming languages. We have also discussed the compilation process as a sequence of phases, with a particular focus on lexical analysis, the process of breaking down the source code into tokens, and syntax analysis, which involves parsing these tokens according to the language's grammar. Finally, we delved into the design and importance of Abstract Syntax Trees, which serve as a crucial intermediate representation of the program's structure for subsequent compiler stages. These theoretical concepts are interconnected and collectively form the essential foundation for the design and implementation of efficient and reliable compiler frontends. The principles discussed here will be directly applicable and further elaborated upon in the subsequent chapters, where we will explore their application in the specific context of the \texttt{tinyC} compiler frontend.